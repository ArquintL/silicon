field f:Int



predicate pred(r:Ref) {
    acc(r.f) && r.f == 0
}

predicate pred2(r:Ref, i:Int) {
    acc(r.f) && r.f == i
}

predicate empty() { true }

/*
method single_predicate(x: Ref)
  requires acc(pred(x))
  ensures acc(pred(x))
{
  unfold pred(x)
  x.f := 0
  fold pred(x)
}*/

/*
method quantified_singleArg(r: Ref, xs: Seq[Ref])
  requires forall x:Ref :: x in xs ==> acc(pred2(x, 0))
  requires acc(pred2(r, 1))
  //ensures forall x:Ref :: x in xs ==> acc(pred(x))
{
  //unfold pred(x)
  //x.f := 3
  //fold pred(x)
}*/


method quantified_multipleArgs(r: Ref, xs: Seq[Ref])
  requires forall x:Ref :: x in xs ==> acc(pred(x))
  //requires r in xs
  requires acc(pred(fun(r)))
  ensures acc(pred(fun(r)))
  //ensures forall x:Ref :: x in xs ==> acc(pred(x))
{
  //unfold pred(x)
  //x.f := 3
  //fold pred(x)
}

function fun(r:Ref):Ref
/*
method quantified_field(r: Ref, xs: Seq[Ref])
  requires forall x:Ref :: x in xs ==> acc(x.f)
  requires acc(fun(r).f)
  ensures acc(fun(r).f)
  //ensures forall x:Ref :: x in xs ==> acc(x.f)
{}*/