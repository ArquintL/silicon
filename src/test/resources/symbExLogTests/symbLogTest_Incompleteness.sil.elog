method m1_1
  WellformednessCheck null
  execute inhale acc(x.f, 1 / 2) && acc(x.f, 1 / 2)
    produce acc(x.f, 1 / 2)
      evaluate x
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      comment: Merge
        Single merge:  <= x@1@01.f -> $t@3@01 # 1/2
    produce acc(x.f, 1 / 2)
      evaluate x
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      comment: Merge
        Single merge: x@1@01.f -> $t@3@01 # 1/2 <= x@1@01.f -> $t@4@01 # 1/2
  execute assert acc(x.f, write)
    consume acc(x.f, write)
      evaluate write
      evaluate x
      Decider assert: W == Z || True
        Prover assert: W == Z || True
      Decider assert: True
      Decider assert: True

method m1_2
  WellformednessCheck null
  execute inhale acc(x.f, 1 / 2) && acc(y.f, 1 / 2)
    produce acc(x.f, 1 / 2)
      evaluate x
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      comment: Merge
        Single merge:  <= x@7@01.f -> $t@10@01 # 1/2
    produce acc(y.f, 1 / 2)
      evaluate y
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      comment: Merge
        Single merge: x@7@01.f -> $t@10@01 # 1/2 <= y@8@01.f -> $t@11@01 # 1/2
          Decider assert: x@7@01 == y@8@01
            Prover assert: x@7@01 == y@8@01
  execute inhale x == y
    produce x == y
      evaluate x == y
        evaluate x
        evaluate y
  execute assert acc(x.f, write)
    consume acc(x.f, write)
      evaluate write
      evaluate x
      Decider assert: W == Z || True
        Prover assert: W == Z || True
      Decider assert: True
      Decider assert: False
        Prover assert: False
      comment: state consolidation
        comment: Round 0
          Single merge:  <= x@7@01.f -> $t@10@01 # 1/2 y@8@01.f -> $t@11@01 # 1/2
            Decider assert: x@7@01 == y@8@01
        comment: Round 1
          Single merge:  <= x@7@01.f -> $t@10@01 # W
      comment: Retry
        Decider assert: True
        Decider assert: True

method m1_3
  WellformednessCheck null
  execute inhale acc(x.f, write) && acc(y.f, write)
    produce acc(x.f, write)
      evaluate x
      evaluate write
      comment: Merge
        Single merge:  <= x@16@01.f -> $t@20@01 # W
    produce acc(y.f, write)
      evaluate y
      evaluate write
      comment: Merge
        Single merge: x@16@01.f -> $t@20@01 # W <= y@17@01.f -> $t@21@01 # W
          Decider assert: x@16@01 == y@17@01
            Prover assert: x@16@01 == y@17@01
  execute inhale z == x || z == y
    produce z == x || z == y
      evaluate z == x || z == y
        evaluate z == x
          evaluate z
          evaluate x
        evaluate !v@23@01 && z == y
          evaluate !v@23@01
            evaluate v@23@01
          evaluate v@24@01 ==> z == y
            evaluate v@24@01
            evaluate z == y
              evaluate z
              evaluate y

method m2_1
  WellformednessCheck null
  execute inhale acc(x.f, 1 / 2) && (acc(x.f, 1 / 2) && x.f == 0)
    produce acc(x.f, 1 / 2)
      evaluate x
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      comment: Merge
        Single merge:  <= x@26@01.f -> $t@28@01 # 1/2
    produce acc(x.f, 1 / 2)
      evaluate x
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      comment: Merge
        Single merge: x@26@01.f -> $t@28@01 # 1/2 <= x@26@01.f -> $t@30@01 # 1/2
    produce x.f == 0
      evaluate x.f == 0
        evaluate x.f
          evaluate x
          Decider assert: True
        evaluate 0
  execute exhale acc(x.f, 1 / 2)
    consume acc(x.f, 1 / 2)
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      evaluate x
      Decider assert: 1/2 == Z || True
        Prover assert: 1/2 == Z || True
      Decider assert: 1/2 == Z
        Prover assert: 1/2 == Z
      Decider assert: True
  execute assert x.f == 0
    consume x.f == 0
      evaluate x.f == 0
        evaluate x.f
          evaluate x
          Decider assert: True
        evaluate 0
      Decider assert: $t@28@01 == 0

method m2_2
  WellformednessCheck null
  execute inhale acc(x.f, 1 / 2) && (acc(y.f, 1 / 2) && x.f == 0)
    produce acc(x.f, 1 / 2)
      evaluate x
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      comment: Merge
        Single merge:  <= x@33@01.f -> $t@36@01 # 1/2
    produce acc(y.f, 1 / 2)
      evaluate y
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      comment: Merge
        Single merge: x@33@01.f -> $t@36@01 # 1/2 <= y@34@01.f -> $t@38@01 # 1/2
          Decider assert: x@33@01 == y@34@01
            Prover assert: x@33@01 == y@34@01
    produce x.f == 0
      evaluate x.f == 0
        evaluate x.f
          evaluate x
          Decider assert: True
        evaluate 0
  execute exhale acc(x.f, 1 / 2)
    consume acc(x.f, 1 / 2)
      evaluate 1 / 2
        evaluate 1
        evaluate 2
        Decider assert: 2 != 0
          Prover assert: 2 != 0
      evaluate x
      Decider assert: 1/2 == Z || True
        Prover assert: 1/2 == Z || True
      Decider assert: True
      Decider assert: True
  execute inhale x == y
    produce x == y
      evaluate x == y
        evaluate x
        evaluate y

method m3_1
  WellformednessCheck null
  execute inhale acc(x.f, write) && (acc(y.f, write) && z == x)
    produce acc(x.f, write)
      evaluate x
      evaluate write
      comment: Merge
        Single merge:  <= x@43@01.f -> $t@47@01 # W
    produce acc(y.f, write)
      evaluate y
      evaluate write
      comment: Merge
        Single merge: x@43@01.f -> $t@47@01 # W <= y@44@01.f -> $t@49@01 # W
          Decider assert: x@43@01 == y@44@01
            Prover assert: x@43@01 == y@44@01
    produce z == x
      evaluate z == x
        evaluate z
        evaluate x
  execute assert x != y
    consume x != y
      evaluate x != y
        evaluate x
        evaluate y
      Decider assert: x@43@01 != y@44@01
        Prover assert: x@43@01 != y@44@01
      comment: state consolidation
        comment: Round 0
          Single merge:  <= x@43@01.f -> $t@47@01 # W y@44@01.f -> $t@49@01 # W
            Decider assert: x@43@01 == y@44@01
              Prover assert: x@43@01 == y@44@01
        Decider assert: True
        Decider assert: True
        Decider assert: $t@49@01 != $t@47@01
          Prover assert: $t@49@01 != $t@47@01
        Decider assert: $t@47@01 != $t@49@01
          Prover assert: $t@47@01 != $t@49@01
      comment: Retry
        evaluate x != y
          evaluate x
          evaluate y
        Decider assert: x@43@01 != y@44@01
  execute inhale acc(z.f, 1 / 10)
    produce acc(z.f, 1 / 10)
      evaluate z
      evaluate 1 / 10
        evaluate 1
        evaluate 10
        Decider assert: 10 != 0
          Prover assert: 10 != 0
      comment: Merge
        Single merge: x@43@01.f -> $t@47@01 # W y@44@01.f -> $t@49@01 # W <= z@45@01.f -> $t@50@01 # 1/10
          Decider assert: x@43@01 == z@45@01
            Prover assert: x@43@01 == z@45@01

