field closure_0: Ref

field discriminant: Int

field enum_Five: Ref

field enum_Four: Ref

field enum_One: Ref

field enum_Three: Ref

field enum_Two: Ref

field f$0: Ref

field f$1: Ref

field f$2: Ref

field f$3: Ref

field f$a: Ref

field f$b: Ref

field f$c: Ref

field f$d: Ref

field f$e: Ref

field f$x: Ref

field f$y: Ref

field f$z: Ref

field val_bool: Bool

field val_int: Int

field val_ref: Ref

function m_OneOfFive$_beg_$_end_$$discriminant$$__$TY$__m_OneOfFive$_beg_$_end_$$int$(self: Ref): Int
  requires acc(m_OneOfFive$_beg_$_end_(self), read$())
  ensures 0 <= result && result <= 4
{
  (unfolding acc(m_OneOfFive$_beg_$_end_(self), read$()) in self.discriminant)
}

function m_SecondEnum$_beg_$_end_$$discriminant$$__$TY$__m_SecondEnum$_beg_$_end_$$int$(self: Ref): Int
  requires acc(m_SecondEnum$_beg_$_end_(self), read$())
  ensures 0 <= result && result <= 1
{
  (unfolding acc(m_SecondEnum$_beg_$_end_(self), read$()) in self.discriminant)
}

function read$(): Perm
  ensures none < result
  ensures result < write


predicate DeadBorrowToken$(borrow: Int) 

predicate bool(self: Ref) {
  acc(self.val_bool, write)
}

predicate char(self: Ref) 

predicate i32(self: Ref) 

predicate m_OneOfFive$_beg_$_end_(self: Ref) {
  acc(self.discriminant, write) && (0 <= self.discriminant && self.discriminant <= 4 && (acc(self.enum_One, write) && (self.discriminant == 0 ==> acc(m_OneOfFive$_beg_$_end_One(self.enum_One), write)) && (acc(self.enum_Two, write) && (self.discriminant == 1 ==> acc(m_OneOfFive$_beg_$_end_Two(self.enum_Two), write)) && (acc(self.enum_Three, write) && (self.discriminant == 2 ==> acc(m_OneOfFive$_beg_$_end_Three(self.enum_Three), write)) && (acc(self.enum_Four, write) && (self.discriminant == 3 ==> acc(m_OneOfFive$_beg_$_end_Four(self.enum_Four), write)) && (acc(self.enum_Five, write) && (self.discriminant == 4 ==> acc(m_OneOfFive$_beg_$_end_Five(self.enum_Five), write))))))))
}

predicate m_OneOfFive$_beg_$_end_Five(self: Ref) 

predicate m_OneOfFive$_beg_$_end_Four(self: Ref) {
  acc(self.f$0, write) && (acc(i32(self.f$0), write) && (acc(self.f$1, write) && (acc(char(self.f$1), write) && (acc(self.f$2, write) && (acc(bool(self.f$2), write) && (acc(self.f$3, write) && acc(bool(self.f$3), write)))))))
}

predicate m_OneOfFive$_beg_$_end_One(self: Ref) 

predicate m_OneOfFive$_beg_$_end_Three(self: Ref) 

predicate m_OneOfFive$_beg_$_end_Two(self: Ref) 

predicate m_SecondEnum$_beg_$_end_(self: Ref) {
  acc(self.discriminant, write) && (0 <= self.discriminant && self.discriminant <= 1 && (acc(self.enum_One, write) && (self.discriminant == 0 ==> acc(m_SecondEnum$_beg_$_end_One(self.enum_One), write))))
}

predicate m_SecondEnum$_beg_$_end_One(self: Ref) {
  acc(self.f$0, write) && acc(bool(self.f$0), write)
}

predicate tuple0$(self: Ref) {
  true
}

predicate usize(self: Ref) 

method m_main() returns (_0: Ref)
{
  var __t0: Bool
  label start
  // ========== start ==========
  
  // Def path: "enum::main"
  
  // Span: cetests/enum.rs:29:1: 29:13 (#0)
  
  __t0 := false
  // Preconditions:
  
  inhale true
  inhale true
  inhale true
  inhale true
  label pre
  // ========== bb0 ==========
  
  __t0 := true
  // [mir] _0 = const ()
  
  // [mir] return
  
  // ========== return ==========
  
  // Target of any 'return' statement.
  
  // Exhale postcondition
  
  label l1
  // Fold predicates for &mut args and transfer borrow permissions to old
  
  // Fold the result
  
  fold acc(tuple0$(_0), write)
  // obtain acc(tuple0$(_0), write)
  
  // Assert possible strengthening
  
  // Assert functional specification of postcondition
  
  // Assert type invariants
  
  assert true
  // Exhale permissions of postcondition (1/3)
  
  // Exhale permissions of postcondition (2/3)
  
  exhale acc(tuple0$(_0), write)
  // Exhale permissions of postcondition (3/3)
  
  goto end_of_method
  label end_of_method
}

method m_foo() returns (_0: Ref)
{
  var __t0: Bool
  var __t1: Bool
  var __t2: Bool
  var __t3: Bool
  var __t4: Bool
  var __t5: Bool
  var __t6: Bool
  var __t7: Bool
  var __t8: Bool
  var __t9: Bool
  var __t10: Bool
  var __t11: Bool
  var __t12: Int
  var __t13: Int
  var _1: Ref
  var _2: Ref
  var _3: Int
  var _4: Ref
  var _5: Ref
  var _6: Int
  var _7: Ref
  var _8: Ref
  var _9: Ref
  var _10: Ref
  label start
  // ========== start ==========
  
  // Def path: "enum::foo"
  
  // Span: cetests/enum.rs:16:1: 27:2 (#0)
  
  __t0 := false
  __t1 := false
  __t2 := false
  __t3 := false
  __t4 := false
  __t5 := false
  __t6 := false
  __t7 := false
  __t8 := false
  __t9 := false
  __t10 := false
  __t11 := false
  // Preconditions:
  
  inhale acc(m_OneOfFive$_beg_$_end_(_1), write) && acc(m_SecondEnum$_beg_$_end_(_2), write)
  inhale true
  inhale true
  inhale true
  label pre
  // ========== bb0 ==========
  
  __t0 := true
  // [mir] FakeRead(ForMatchedPlace, _1)
  
  // [mir] _3 = discriminant(_1)
  
  _3 := builtin$havoc_int()
  inhale true
  _3 := m_OneOfFive$_beg_$_end_$$discriminant$$__$TY$__m_OneOfFive$_beg_$_end_$$int$(_1)
  // [mir] switchInt(move _3) -> [0_isize: bb1, 3_isize: bb3, otherwise: bb2]
  
  __t12 := _3
  if (__t12 == 0) {
    goto bb3
  }
  if (__t12 == 3) {
    goto l0
  }
  goto bb0
  label bb0
  // ========== l0 ==========
  
  // MIR edge bb0 --> bb2
  
  // ========== bb2 ==========
  
  __t1 := true
  // [mir] _0 = const true
  
  _0 := builtin$havoc_ref()
  inhale acc(_0.val_bool, write)
  _0.val_bool := true
  // [mir] goto -> bb11
  
  goto bb5
  label bb2
  // ========== bb10 ==========
  
  __t8 := true
  // [mir] StorageDead(_5)
  
  // [mir] StorageDead(_4)
  
  // [mir] goto -> bb11
  
  // ========== l12 ==========
  
  fold acc(bool(_1.enum_Four.f$2), write)
  fold acc(bool(_1.enum_Four.f$3), write)
  fold acc(m_OneOfFive$_beg_$_end_Four(_1.enum_Four), write)
  fold acc(m_OneOfFive$_beg_$_end_(_1), write)
  // drop Acc(_5.val_bool, write) (Acc(_5.val_bool, write))
  
  // drop Acc(_6.val_int, write) (Acc(_6.val_int, write))
  
  // drop Acc(_4.val_bool, write) (Acc(_4.val_bool, write))
  
  goto bb5
  label bb3
  // ========== l1 ==========
  
  // MIR edge bb0 --> bb1
  
  // ========== bb1 ==========
  
  __t9 := true
  // [mir] falseEdge -> [real: bb4, imaginary: bb3]
  
  // ========== bb4 ==========
  
  __t10 := true
  // [mir] _0 = const true
  
  _0 := builtin$havoc_ref()
  inhale acc(_0.val_bool, write)
  _0.val_bool := true
  // [mir] goto -> bb11
  
  goto bb5
  label bb5
  // ========== bb11 ==========
  
  __t11 := true
  // [mir] return
  
  // ========== return ==========
  
  // Target of any 'return' statement.
  
  // Exhale postcondition
  
  label l11
  // Fold predicates for &mut args and transfer borrow permissions to old
  
  // Fold the result
  
  fold acc(bool(_0), write)
  // obtain acc(bool(_0), write)
  
  // Assert possible strengthening
  
  // Assert functional specification of postcondition
  
  assert (unfolding acc(bool(_0), write) in _0.val_bool)
  // Assert type invariants
  
  assert true
  // Exhale permissions of postcondition (1/3)
  
  // Exhale permissions of postcondition (2/3)
  
  exhale acc(bool(_0), write)
  // Exhale permissions of postcondition (3/3)
  
  goto end_of_method
  label l0
  // ========== l2 ==========
  
  // MIR edge bb0 --> bb3
  
  // ========== bb3 ==========
  
  __t2 := true
  // [mir] falseEdge -> [real: bb5, imaginary: bb2]
  
  // ========== bb5 ==========
  
  __t3 := true
  // [mir] StorageLive(_4)
  
  // [mir] _4 = ((_1 as Four).2: bool)
  
  _4 := builtin$havoc_ref()
  inhale acc(_4.val_bool, write)
  unfold acc(m_OneOfFive$_beg_$_end_(_1), write)
  unfold acc(m_OneOfFive$_beg_$_end_Four(_1.enum_Four), write)
  unfold acc(bool(_1.enum_Four.f$2), write)
  _4.val_bool := _1.enum_Four.f$2.val_bool
  label l3
  // [mir] StorageLive(_5)
  
  // [mir] _5 = ((_1 as Four).3: bool)
  
  _5 := builtin$havoc_ref()
  inhale acc(_5.val_bool, write)
  unfold acc(bool(_1.enum_Four.f$3), write)
  _5.val_bool := _1.enum_Four.f$3.val_bool
  label l4
  // [mir] FakeRead(ForMatchedPlace, _2)
  
  // [mir] _6 = discriminant(_2)
  
  _6 := builtin$havoc_int()
  inhale true
  _6 := m_SecondEnum$_beg_$_end_$$discriminant$$__$TY$__m_SecondEnum$_beg_$_end_$$int$(_2)
  // [mir] switchInt(move _6) -> [0_isize: bb6, 1_isize: bb7, otherwise: bb8]
  
  __t13 := _6
  // Ignore default target bb8, as the compiler marked it as unreachable.
  
  if (__t13 == 0) {
    goto l2
  }
  goto l1
  label l1
  // ========== l5 ==========
  
  // MIR edge bb5 --> bb7
  
  // ========== bb7 ==========
  
  __t5 := true
  // [mir] falseEdge -> [real: bb9, imaginary: bb6]
  
  // ========== bb9 ==========
  
  __t6 := true
  // [mir] _0 = const true
  
  _0 := builtin$havoc_ref()
  inhale acc(_0.val_bool, write)
  _0.val_bool := true
  // [mir] goto -> bb10
  
  goto bb2
  label l2
  // ========== l6 ==========
  
  // MIR edge bb5 --> bb6
  
  // ========== bb6 ==========
  
  __t7 := true
  // [mir] StorageLive(_7)
  
  // [mir] _7 = ((_2 as One).0: bool)
  
  _7 := builtin$havoc_ref()
  inhale acc(_7.val_bool, write)
  unfold acc(m_SecondEnum$_beg_$_end_(_2), write)
  unfold acc(m_SecondEnum$_beg_$_end_One(_2.enum_One), write)
  unfold acc(bool(_2.enum_One.f$0), write)
  _7.val_bool := _2.enum_One.f$0.val_bool
  label l7
  // [mir] StorageLive(_8)
  
  // [mir] StorageLive(_9)
  
  // [mir] _9 = _4
  
  _9 := builtin$havoc_ref()
  inhale acc(_9.val_bool, write)
  _9.val_bool := _4.val_bool
  label l8
  // [mir] StorageLive(_10)
  
  // [mir] _10 = _5
  
  _10 := builtin$havoc_ref()
  inhale acc(_10.val_bool, write)
  _10.val_bool := _5.val_bool
  label l9
  // [mir] _8 = BitXor(move _9, move _10)
  
  _8 := builtin$havoc_ref()
  inhale acc(_8.val_bool, write)
  _8.val_bool := !(_9.val_bool == _10.val_bool)
  // [mir] StorageDead(_10)
  
  // [mir] StorageDead(_9)
  
  // [mir] _0 = Not(move _8)
  
  _0 := builtin$havoc_ref()
  inhale acc(_0.val_bool, write)
  _0.val_bool := !_8.val_bool
  // [mir] StorageDead(_8)
  
  // [mir] StorageDead(_7)
  
  // [mir] goto -> bb10
  
  // ========== l10 ==========
  
  fold acc(bool(_2.enum_One.f$0), write)
  fold acc(m_SecondEnum$_beg_$_end_One(_2.enum_One), write)
  fold acc(m_SecondEnum$_beg_$_end_(_2), write)
  // drop Acc(_8.val_bool, write) (Acc(_8.val_bool, write))
  
  // drop Acc(_10.val_bool, write) (Acc(_10.val_bool, write))
  
  // drop Acc(_9.val_bool, write) (Acc(_9.val_bool, write))
  
  // drop Acc(_7.val_bool, write) (Acc(_7.val_bool, write))
  
  goto bb2
  label return
  // ========== bb8 ==========
  
  __t4 := true
  // [mir] unreachable
  
  goto end_of_method
  label end_of_method
}

method builtin$havoc_ref() returns (ret: Ref)


method builtin$havoc_bool() returns (ret: Bool)


method builtin$havoc_int() returns (ret: Int)
