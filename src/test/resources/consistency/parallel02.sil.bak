method test01(b1: Bool, n: Int) {
  inhale n > 1000

  var idfun100: Int := 100
  var idfun200: Int := 200

  var SLEEP: Bool := true

  if (b1) {
    assert n > idfun100
    assert SLEEP
  } else {
    assert n > idfun200
    assert SLEEP
  }
}

method test02(b1: Bool, b2: Bool, n: Int) {
  inhale n > 1000

  var idfun100: Int := 100
  var idfun200: Int := 200
  var idfun300: Int := 300
  var idfun400: Int := 400
  var idfun500: Int := 500
  var idfun600: Int := 600

  var SLEEP: Bool := true

  if (b1) {
    assert n > idfun100
    if (b2) {
      assert n > idfun200
      assert SLEEP
    } else {
      assert n > idfun300
      assert SLEEP
    }
  } else {
    assert n > idfun400
    if (b2) {
      assert n > idfun500
      assert SLEEP
    } else {
      assert n > idfun600
      assert SLEEP
    }
  }
}

field f: Int

predicate C(b: Bool, x: Ref) { b ==> acc(x.f, wildcard) }

method test03(b1: Bool, b2: Bool, n: Int, x: Ref) {
  inhale n > 1000
  inhale C(b1, x)
  inhale C(b2, x)

  unfold C(b1, x)
  unfold C(b2, x)

  var SLEEP: Bool := true

  assert SLEEP
}

function fun01(b: Bool, x: Ref): Int
  requires b ==> acc(x.f, wildcard)
  requires !b ==> C(!b, x)
  ensures result >= 1
{
  !b ? unfolding C(!b, x) in 1 : 2
}

method test04(b: Bool, x: Ref) {
  inhale C(b, x)

  assert unfolding C(b, x) in true
}
